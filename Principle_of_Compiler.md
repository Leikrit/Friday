# Lesson 1
## introduction

### Errors

- Lexical error
- Syntax error
- Semantic (语义) error
- Logic error

***
Java的判断语句只能为```true```或者```false```

```java
if(a%2) //Semantic error

if(a%2==0) //Correct
```
***

### Intermediate Code

To optimize the program.

### Black Box

Analysis:
- Scanner/Lexer
- Parser (语法剖析程式)
- Semantic Analysis

Synthesis:
- Code Optimizer
- Code generator

### Front end and Back end

#### Front end

Operations that depend only on the source language, include: the scanner, parser, and semantic analyzer, source code optimizer.

From Scanner to Intermediate Code Optimizer and Genetator

#### Back end

Operations that depend only on the target language, include: code generator, target code optimizer.

### Realization of compiler structure

Compiler may repeat one or more passes before generating target code.

#### Definition of Pass

A **pass** is to process of the entire source program or it's intermediate representation one time.

- A typical arrangement is one pass for scanning and parsing, one pass for semantic analysis and source-level optimization, and a third pass for code generation and target level optimization.

- How many times depend on the source language and the target machine.



### Interpreter and Compiler

Similarity:

- They are all language implementing system.

Differences:

- Interpreter executes the source program during translation.

- Compiler generates object code that is executed after translation completes.

***

**The Translation Process**
- Scanner
- Parser
- Semantic Analyzer
- Code Optimizer
- Code Generator


## Scanner

Scanner performs lexical analysis.

### Task of Scanner

Reading the source program as a file of characters and dividing it up into meaningful units called **tokens**.

- Input: source program which is a stream of characters.
- Output: tokens.

### Token

Each token is a sequence of characters that represents a unit of information in the source program.

Tokens fall into several categories:

- Identifier
- Keyword
- Number
- Operator
- Special symbols 

Token is presented as **(Kind, Value)**

> New lines should be remembered since the position of errors should be reporte.

### Other operations performed by scanner

- Enter identifiers into the symbol table.
- Enter literals in literal table.

> Literals include: numeric constants and quoted string of text.

### Literal pool

#### New or not
In different programming languages, the operator ```==``` performs different comparisons. In Java, it compares two variables' address. In C++, it compares two variables' contents.

That means in Java:

```Java
a1 = "Hello world";
a2 = "Hello world";
a3 = a1;
a1 ==a2; // True
a1 == a3; // True
a4 = new string "Hello world";
a1 == a4; // False
```

## Parser

Parser performs syntax analysis.

### Task of parser

The parser receives the source code in the form of tokens from the scanner and performs the syntax analysis, which determines the structure of the program.

- input: stream of tokens

- output: parse tree or syntax tree

### Parser tree

Parser tree is a useful aid to visualizing the syntax of a program or program element.

### Abstract Syntax Tree (Syntax Tree)

A condensation of the information contained in the parser tree.

## Semantic analyzer

- Semantics of a program are its "meanings".
- **Static semantic**: properties of a program that can be determined prior to execution.
- **Dynamic semantic**: properties of a program that can only be determined by execution.

### Task of Semantic Analyzer

Analyze static semantic.

### Static Semantics include

- Declaration 
- Type checking

Semantic analysis is realized by symbol table. Attributes are entered into symbol table.

### Output of semantic analyzer

Semantic analyzer will produce an annotated tree. Attributes are added to the tree as annotations.

## Source Code Optimizer

Optimization performs after semantic analysis that depend only on the source code.

- Some optimizations can be performed directly on the syntax tree.

- It is easier to optimize using **Intermediate Code**.

## Intermediate code (optional)

- A form of code representation intermediate between source code and object code.

- Intermediate codes have the following properties: structure is simple, meaning is clear, and it is easy to translate them to object code.

### Intermediate Representation (IR)
- Any internal representation for the source code used by the compiler is called IR.
- The syntax tree and intermediate code are all IR.

## Code Generator 

### Task of code generator

- The code generator takes the IR and generates code for the target machine.
- Usually use assembly language as target code.
- It is related to the properties of target machine: the number of registers, addressing mode, data representation and so on.

## Target Code Optimizer

### Task of the target code opimizer

To improve the target code generated by the code generator, saving execution time and memory space.

This opimization includes:

- Change addressing mode to improve performance
- Replaceslow instructions by faster ones
- Eliminate redundant or unnecssary operations

## Auxiliary Components of Compiler Phases

### Literal Table

#### Usage of Literal Table

Literal table stores constants and strings used in a program.

#### Purpose of Literal Table

The literal table is important in reducing the size of a program in memory by allowing the reuse of constants and strings.

### Symbol Table

#### Usage of Symbol Table

Symbol table keeps information associated to identifiers: functions,variables, constants and data type identifiers.

#### Symbol table with compiler phases

- Scanner, parser or semantic analyzer may enter identifiers and information into the table.

- The optimization and code generation will use the information provided by the symbol table.

## Error Handler

- Errors can be detected during almost every compiler phase.

- Error handler must generate meaningful error message and resume compilation after each other.




# Scanning

## Scanning Process

- The task of scanner
Reading the source program as a file of characters and diving it up into **tokens**.

- Tokens

    - Token is a sequence of characters that represents a unit of information.

    - Token represents a certain pattern of characters, such as keywords, identifiers, literals, special symbols, etc.

### Categories of Tokens

- Keywords
- Identifiers
- Literals
- Special symbols (operators, delimiters, etc.)

#### Tokens and Lexeme

- Token is persented as (Kind,Value)
- Kinds are logical entities, represented as IF, THEN, PLUS, MINUS, NUM, ID and so on.
- The string value represented by a token is called **lexeme**.
    - Reserved words and special symbol have only one lexeme
    - While number and identifier have infinitely many lexemes
 

### Interface of Scanner

- Scanning is a single pass
Convert the entire source program into a sequence of tokens.
- Scanning is a sub function of the parser
When called by the parser it returns the single next token from the input.




## Regular Expression (RE) 正则表达式

- Function
Represent patterns of strings of characters.
- THe meaning of regular expression
    - A regular expression **$r$** is completely defined by the set of strings that it matches.
    - This set is called the **language generated by the regular expression**, written as $L(r)$.
    - $L(r)$ is defined on a set of symbol called alphabet $\Sigma$.

### String and Language

#### 1. Alphabet
- Definition
Any finite set of symbols.
- Example
$\Sigma=\{0,1\}$ ; $A=\{a, b, c\}$

#### 2. String
-Definition
A string over some alphabet is a finite sequence of symbols drawn from that alphabet.
- Examples
0, 00, 10 are strings of $\Sigma=\{0, 1\}$
a, ab, aaca are strings of $A=\{a, b, c\}$

- Length of string
    - The length of a string $s$, usually written as $|s|$, is the number of occurances of symbols in $s$.
    - Example: $|abc|=3$

- The empty string
    - Denoted by $\varepsilon$, is a special string of length zero
    - $\{\varepsilon\}$ is not equal to $\Phi (\{\})$

#### 3. Operations on string

- Concatenation
    - If $x$ and $y$ are strings, then the concatenation of $x$ and $y$, written as $xy$, is the string formed by appending $y$ to $x$
    - Example: $x=ST$, $y=abu$, $xy=STabu$
    $\varepsilon x=x\varepsilon=x$

- Exponentiation
    - If $a$ is a string then $a^n=aa...aa$
    - Example: $a^1=a$, $a^2=aa$, $a^0=\varepsilon$

#### 4. Language
- Definition
Any set of strings over some fixed alphabet
-Example
    - $\{\varepsilon\}$ is a language
    - $\Phi$, the empty set is also a language

#### 5. Operations on langauge
- Concatenation
    - Concatenation of $L$ and $M$ is written as $LM$, $LM=\{st|s\in L, t\in M\}$
    - Example:
    $L=\{ab, cde\}$, $M=\{0, 1\}$
    $LM=\{ab0,ab1,cde0,cde1\}$
    - $\{\varepsilon\}A=A\{\varepsilon\}=A$

- Exponentiation
The exponentiation of $L$ is defined as:
    - $L^0=\{\varepsilon\}$
    - $L^1=L$, $L^2=LL$
    - $L^K=LL...L$ ($L^K$ is $L$ concatenated with itself $K-1$ times)

- **Closure**
    - Closure of $L$ (written as $L^*$) denotes **zero** or more concatentaions of $L$.
    - $L^*=L^0 \cup L^1 \cup L^2 \cup L^3 \cup ...$
    - Example: 
  
    $$\begin{aligned}
    L&=\{0,1\} \\
    L^*&=L^0 \cup L^1 \cup L^2 \cup L^3 \cup ...\\
    &=\{\varepsilon,0,1,00,01,10,11,000,...\}
    \end{aligned}$$

    - Positive closure of $L$ (written as $L+$) denotes **one** or more concatenation of $L$.
    - Example:
 
    $$\begin{aligned}
    L^+&=L^1 \cup L^2 \cup L^3 \cup ... \\
    L^*&=L^0 \cup L^+\\
    L^+&=LL^*=L^*L
    \end{aligned}$$

## Definition of Regular Expressions
- The set of basic regular expression
- Essential set of operations that generate new regular expression from existing ones.

A regular expression is one of the following:
1. $\varepsilon$ and $\phi$ are regular expressions, $L(\varepsilon)=\{\varepsilon\}$, $L(\phi)=\phi$
2. Any $a \in \Sigma$ is a regular expression of $\Sigma$, $L(a)=\{a\}$
3. if $e_1$ and $e_2$ are regular expressions of $\Sigma$, then the following are all regular expressions of $\Sigma$:

| regular expression | language generated by the regular expression |
| ---- | ---- |
| $(e_1)$ | $L(e_1)$ |
| $e_1\|e_2$ | $L(e_1) \cup L(e_2)$ |
| $e_1e_2$ | $L(e_1)L(e_2)$ |
| $e_1^*$ | $(L(e_1))^*$ |

- Operations that generate new regular expression from existing ones are:
    - Choice among alternatives (**|**)
    - Concatenation (**.**)
    - Repetition or closure (**\***)
- The precedence of the operations is:
$$*>.>|$$
- Example

$$\begin{aligned}
L(a|bc^*)&=\{a\} \cup (\{b\}\{\varepsilon,c,cc,...\}) \\
&= \{a\} \cup \{ b,bc,bcc,...\} \\
&= \{a,b,bc,bcc,...\}
\end{aligned}$$




\$\|\_\|l(l\|\_\|\$|d)*

## Finite Automata (FA) 有穷自动机

- Determined Finite Automata (DFA)
- Nondetermined Finite Automata (NFA)

